---
title: "Process&Thread"
date: 2020-07-05 22:32:28 -0400
categories: OS_Study
---

# 병행 프로세스의 개념

- 독립 프로세스 : 단일 처리 시스템에서 수행하는 병행 프로세스. 다른 프로세스에 영향을 주고받지 않으면서 독립적으로 실행함
   - 단일 프로그래밍 : 프로세서를 사용 중이던 프로세스를 완료한 후 다른 프로세스를 실행한다
   - 다중 프로그래밍 : 프로세스 여러 개가 프로세서 하나를 공유함. 공유하지 않는 상태일 때 디스패치 순서는 상관 없음
   - 다중 처리 : 프로세서를 2개 이상 사용하여 동시에 프로그램 여러 개를 병렬로 실행함. 프로세스는 한 번에 프로세서 하나에서 실행하지만, 동일한 시스템에서는 서로 다른 시간에 서로 다른 프로세서에서 실행할 수 있음
- 협력 프로세스 : 다른 프로세스와 상호작용하며 특정 기능을 수행하는 비동기적 프로세스. 메모리, 입출력장치, 프로세스, 클록 등 자원을 서로 사용하려고 하여 충돌이 발생하는데, 이런 자원들은 다른 프로세스의 영향을 받거나 상태가 변하면 안되므로 다음 3가지 형태로 상호작용을 함
   - 프로세스는 서로 인식하지 못하는 경쟁 관계를 유지함
   	- ex) 운영체제가 자원 경쟁을 고려하여 동일한 디스크나 프린터로 접근을 조절
   - 프로세스는 입출력 버스를 비롯한 개체를 공유하는 단계에서 간접적으로 서로의 관계를 인식함
   - 프로세스에는 서로를 인식하고 프로세스끼리 통신할 수 있는 기본 함수가 있음. 프로세스가 서로 협력 관계에 있으면 직접 통신이 가능하고 병행해서 함께 동작함



# 선행 그래프와 병행 프로그램

 - fork와 join 구조
 	- fork L 문장을 사용하면 병행 프로세스를 2개 생성
 		- 하나는 레이블이 L인 문장에서 수행을 시작
 		- 다른 하나는 fork 명령어 바로 다음 문장에서 시작
 	- join 명령어는 병행 연산 2개를 하나로 결합하는 방법을 제공
 		- 연산 2개를 수행 중이라고 할 때 이 둘의 속도가 다르므로 둘 중 하나는 join을 먼저 수행
 		- join 후에 다른 연산을 수행


# 병행 문장

 - 병행 문장은 하나의 프로세스가 여러 병렬 프로세스로 퍼졌다가 다시 하나로 뭉쳐지는 것을 나타는는 언어 구조



* * *

# 상호배제의 개념

 - 병행 프로세스에서 프로세스 하나가 공유 자원을 사용할 때 다른 프로세스들이 동일한 일을 할 수 없도록 하는 방법
 - 동기화 : 공유 자원을 동시에 사용하지 못하게 실행을 제어하는 방법
 	- 동기화로 상호배제를 보장할 수는 있지만, 교착 상태와 기아 상태가 발생할 수 있음
 - 프로세스가 다른 프로세스와 충돌하지 않는 연산을 할 때는 프로세스를 동시에 수행하도록 허용해야 하므로, 다음 네 가지 조건을 만족해야 함
 	- 두 프로세스는 동시에 공유 자원에 진입할 수 없다
 	- 프로세스의 속도나 프로세서 수에 영향을 받지 않는다
 	- 공유 자원을 사용하는 프로세스만 다른 프로세스를 차단할 수 있다
 	- 프로세스가 공유 자원을 사용하려고 너무 오래 기다려서는 안 된다



# 임계 영역

 - 어떤 프로세스가 임계 영역에 들어가면 다른 프로세스는 임계 영역으로 진입할 수 없어야 함



# 생산자 소비자 문제와 상호배제를 해결하는 시도

 - 생산자 소비자 문제는 운영체제에서 비동기적으로 수행하는 모델로, 생산자 프로세스가 생산한 정보를 소비자 프로세스가 소비하는 형태
 - 생산자는 소비자에게 데이터를 전송할 때, 데이터를 소비자가 받을 준비가 되면 데이터를 전송하고 소비자가 계속 처리하지 못하면 대기 함
 - 소비자가 데이터를 받을 준비를 마칠 때 까지 생산자는 버퍼로 데이터를 전송하도록 하면 됨




* * *

#데커의 알고리즘

 - 두 프로세스가 동시에 임계 영역에 진입하려고 시도하면 순서에 따라 오직 하나만 임계 영역에 들어가도록 허용
 - 프로세스가 임계 영역에 진입하고 싶으면 플래그를 성정라혹 대기함
 - 임계 영역에 다른 프로세스가 이미 있으면 해당 프로세스를 종료할 때까지 while 문에서 순환함
 - 특별한 하드웨어 명령문이 필요없고, 임계 영역 바깥에서 수행 중인 프로세스가 다른 프로세스들이 임계 영역에 들어가려는 것을 막지 않으며, 임계 영역에 들어가기를 원하는 프로세서를 무한정 기다리게 하지 않음



# TestAndSet 명령어

 - 하드웨어에서 명령을 사용하므로 알고리즘이 간단하고, 하나의 메모리 사이클에서 수행하여 공유 변수를 수정해서 발생하는 경쟁 상황을 해결할 수 있음
 - 2개의 기계 명령어를 사용
 	- 원자적 연산 명령어 TestAndSet
 	- TestAndSet에 지역변수 lock을 설정하는 명령어
 - TestAndSet
 	- 읽기와 쓰기를 모두 제공함
 	- 해당 주소의 값을 읽고 새 값으로 교체하면서 해당 메모리 위치의 이전 값을 돌려줌



# 세마포

 - 위 2개는 진입 조건을 반복하여 조사하기 때문에 프로세서 사이클 낭비가 심함
 - 세마포가 이 문제를 해결함
 - 상호배제 뿐만 아니라 다양한 연산의 순서도 제공함

 - 세마포 개념과 동작
 	- 음이 아닌 정수 플래그 변수
 	- P연산(감소연산), V연산(증가연산)
 	- 세마포를 의미하는 S는 표준 단위 연산 P(프로세스를 대기하게 하는 wait동작으로, 임계 영역에 진입하는 연산)와 V(대기 중인 프로세스를 깨우려고 신호를 보내는 signal 동작으로, 임계영역에서 나오는 연산)로만 접근 가능함
 	- 이들은 운영체제가 실행함

//------------------------------------------------

P(S) : wait(S) {
	while S <= 0
    S--;
}

// 다른 프로세스의 접근 허용
V(S) : signal(S) {
	S++;
}

출처 : 그림으로 배우는 구조와 원리 운영체제 p.162

//------------------------------------------------

 - 세마포의 종류
 	- 계수 세마포 : 생산자 소비자 문제처럼 상호배제와 조건부 동기화를 해결하기 위해 설계
 	- 이진 세마포 : 임계 영역처럼 특별히 상호배제를 해결하려고 설계

 - 세마포의 연산
//------------------------------------------------

wait 연산
wait(S){
	S->count--;
    if(S->count < 0){
   		add this process to S->queue; // 프로세스를 준비 큐에 추가
        block();					  // 프로세스 중단(일시정지)
    }
}

signal 연산
signal(S){
	S->count++;
    if(S->count <=0){
    	remove a process P from S -> queue; // 준비 큐에서 P 프로세스를 제거
        wakeup(P)							// 신호를 보내 프로세스를 실행
    }
}

출처 : 그림으로 배우는 구조와 원리 운영체제 p.168

//------------------------------------------------